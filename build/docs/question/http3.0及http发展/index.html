<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="卫辰 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="卫辰 Blog Atom Feed"><title data-react-helmet="true">http3.0 及 http发展历史 | 卫辰</title><meta data-react-helmet="true" property="og:url" content="http://githubci.faithcal.com/docs/question/http3.0及http发展"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="http3.0 及 http发展历史 | 卫辰"><meta data-react-helmet="true" name="description" content="http3.0"><meta data-react-helmet="true" property="og:description" content="http3.0"><link data-react-helmet="true" rel="shortcut icon" href="/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://githubci.faithcal.com/docs/question/http3.0及http发展"><link data-react-helmet="true" rel="alternate" href="http://githubci.faithcal.com/docs/question/http3.0及http发展" hreflang="en"><link data-react-helmet="true" rel="alternate" href="http://githubci.faithcal.com/docs/question/http3.0及http发展" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.2a08f740.css">
<link rel="preload" href="/assets/js/runtime~main.047caa76.js" as="script">
<link rel="preload" href="/assets/js/main.da97ff1e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">卫辰</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">大前端</a><a class="navbar__item navbar__link" href="/md/devops">devops</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_cxYs react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">卫辰</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/intro">大前端</a></li><li class="menu__list-item"><a class="menu__link" href="/md/devops">devops</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">博客</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_lDyR"><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu menu--responsive thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_iZzd" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/browser/base-1">base-1</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">函数速查</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/function/searchPrams">searchPrams</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">javascript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/Proxy&amp;Reflect">Proxy 和 Reflect</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/design-pattern">设计模式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/eventloop">EventLoop</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/javascript-functional">函数式编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/meta-programming">元编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/JavaScript高级技巧">JavaScript高级技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/javaScript常见的错误类型">javaScript常见的错误类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/try-catch-finally执行顺序">有return的情况下try catch finally的执行顺序</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">node</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-framework">NodeJS 项目架构与优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-ioc">NodeJS 面向切面编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-performance">NodeJS 性能调优</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-ssr">NodeJS 服务端渲染</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">性能调优</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/http">HTTP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/node-performance">NodeJS 性能调优</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-1">性能优化(一)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-2">性能优化(二)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-3">性能优化(三)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">其他</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/C">C语言速成</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/CPP">C++ 速成</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/docker-publish">Docker 镜像打包和发布基本流程</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">问题描述</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/BFC">BFC相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/react-fiber">react的react-fiber</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vueHooks">vue 中的Hooks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/DNS的解析过程">DNS的解析过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/React中的有状态和无状态组件">React 中的有状态组件和无状态组件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/React动态加载路由实现按需加载">React 路由的动态加载模块，实现按需加载</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/Redux属性传递的原理">Redux怎么实现属性传递，介绍下原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/TreeShaking的原理">tree-shaking 的原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/css-旋转图片">css一直旋转的图片</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/css-水波纹">css水波纹</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/dev-server的运行">dev-server 是怎么跑起来的</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/question/http3.0及http发展">http3.0 及 http发展历史</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/https获取加密秘钥的过程">https 获取加密秘钥的过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/localStorage加密原理">LocalStorage 加密原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/react中的diff">react diff算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue&amp;react的异同">vue&amp;react的理解和他们的异同</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue.$set原理">vue的 $set原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue中$方法说明">vue 中所有带$方法的说明</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue中的v-model">vue 中的v-model</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的data改编后会重新渲染吗">vue 中data中某个属性改变会触发视图重新渲染的吗</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的dom-diff算法">vue中的dom diff算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的keep-alive">vue keep-alive的实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的nextTick原理">vue的$nextTick原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的seo">vue 针对搜索引擎的seo优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的指令">vue中的指令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue移动端滚动穿透问题">vue移动端滚动穿透问题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue组件的通信方式">vue组件的通信方式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack插件的实现">webpack中插件的实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack热更新原理">webpack 热更新原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的loader和plugin">webpack 的loader和plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的优化">webpack 及其优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的模块引用">webpack是怎么处理模块循环引用的情况的?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/从URL到页面加载分析">从输入 URL 到页面加载全过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/前端的单元测试">前端中的单元测试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/可提供代码执行环境的沙箱">场景：需求前端有一个编辑器，可提供执行代码的功能，这个执行的沙箱需要注意什么，怎么实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/在H5中实现长按保存图片">在H5中实现长按保存图片</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/增量式垃圾回收算法怎么实现的">增量式垃圾回收算法怎么实现的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/对react的看法">对react的看法，它的优缺点，使用过程中遇到的问题，如何解决的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/浏览器渲染流程">浏览器渲染流程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/浏览器里点击复制到剪贴板">浏览器里点击复制到剪贴板的方法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/组件曝光SDK">埋点场景题：如何设计一个通过组件曝光的sdk（计算路由跳转层级、停留时间等）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/网站的seo处理">网站的seo处理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/虚拟DOM">对虚拟DOM的理解?虚拟DOM主要做了什么?虚拟DOM本身是什么?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/解析HTML的过程">浏览器解析 HTML 文件的过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/首页优化">提升页面性能和首页优化</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">docker</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker image Build 高级">Docker image Build 高级</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker-compose基本语法">Docker-compose基本语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Dockerfile语法">Dockerfile语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker基础速查">Docker基础速查</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker网络化配置">Docker网络化配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Namespace-网络">Namespace-网络</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Yaml语法">Yaml语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/docker中进程的信号">docker中进程的信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/安装Docker软件">安装Docker软件</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Kubernetes</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s/k8s-前置环境">k8s-前置环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s/redhat8安装docker">redhat8安装docker</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TypeScript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/开篇：用正确的方式学习 TypeScript">开篇：用正确的方式学习 TypeScript</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/工欲善其事：打造最舒适的 TypeScript 开发环境">工欲善其事：打造最舒适的 TypeScript 开发环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/进入类型的世界：理解原始类型与对象类型">进入类型的世界：理解原始类型与对象类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/掌握字面量类型与枚举，让你的类型再精确一些">掌握字面量类型与枚举，让你的类型再精确一些</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/函数与 Class 中的类型：详解函数重载与面向对象">函数与 Class 中的类型：详解函数重载与面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/探秘内置类型：any、unknown、never 与类型断言">探秘内置类型：any、unknown、never 与类型断言</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程好帮手：TypeScript 类型工具（上）">类型编程好帮手：TypeScript 类型工具（上）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程好帮手：TypeScript 类型工具（下）">类型编程好帮手：TypeScript 类型工具（下）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程基石：TypeScript 中无处不在的泛型">类型编程基石：TypeScript 中无处不在的泛型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/结构化类型系统：类型兼容性判断的幕后">结构化类型系统：类型兼容性判断的幕后</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型系统层级：从 Top Type 到 Bottom Type">类型系统层级：从 Top Type 到 Bottom Type</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型里的逻辑运算：条件类型与 infer">类型里的逻辑运算：条件类型与 infer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/内置工具类型基础：别再妖魔化工具类型了！">内置工具类型基础：别再妖魔化工具类型了！</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/反方向类型推导：用好上下文相关类型">反方向类型推导：用好上下文相关类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/函数类型：协变与逆变的比较">函数类型：协变与逆变的比较</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/了解类型编程与类型体操的意义，找到平衡点">了解类型编程与类型体操的意义，找到平衡点</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/内置工具类型进阶：类型编程进阶">内置工具类型进阶：类型编程进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基础类型新成员：模板字符串类型入门">基础类型新成员：模板字符串类型入门</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程新范式：模板字符串工具类型进阶">类型编程新范式：模板字符串工具类型进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/工程层面的类型能力：类型声明、类型指令与命名空间">工程层面的类型能力：类型声明、类型指令与命名空间</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/在 React 中愉快地使用 TypeScript：内置类型与泛型坑位">在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍">让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/全链路 TypeScript 工具库，找到适合你的工具">全链路 TypeScript 工具库，找到适合你的工具</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/说说 TypeScript 和 ECMAScript 之间那些事儿">说说 TypeScript 和 ECMAScript 之间那些事儿</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/装饰器与反射元数据：了解装饰器基本原理与应用">装饰器与反射元数据：了解装饰器基本原理与应用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/控制反转与依赖注入：基于装饰器的依赖注入实现">控制反转与依赖注入：基于装饰器的依赖注入实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/TSConfig 全解（上）：构建相关配置">TSConfig 全解（上）：构建相关配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/TSConfig 全解（下）：检查相关、工程相关配置">TSConfig 全解（下）：检查相关、工程相关配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基于 Prisma + NestJs 的 Node API ：前置知识储备">基于 Prisma + NestJs 的 Node API ：前置知识储备</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署">基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/玩转 TypeScript AST：AST Checker 与 CodeMod">玩转 TypeScript AST：AST Checker 与 CodeMod</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">工程化</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/devops/CICD">前端工程化之CI/CD</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/devops/K8S">K8S 基础</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="markdown"><header><h1 class="h1Heading_dC7a">http3.0 及 http发展历史</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http30"></a>http3.0<a class="hash-link" href="#http30" title="Direct link to heading">#</a></h2><p>HTTP3.0, 也称作HTTP over QUIC。 HTTP3.0 的核心是QUIC(读音quick)协议， 由Google 在2015 年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议， 可以定义成:HTTP3.0基于UDP的安全可靠的HTTP2.0 协议。</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-031627.png"></p><blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="quic协议针对基于tcp和tls的http20-协议解决了下面的问题"></a>QUIC协议针对基于TCP和TLS的HTTP2.0 协议解决了下面的问题:<a class="hash-link" href="#quic协议针对基于tcp和tls的http20-协议解决了下面的问题" title="Direct link to heading">#</a></h3></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="减少了tcp三次握手及tls-握手时间"></a>减少了TCP三次握手及TLS 握手时间<a class="hash-link" href="#减少了tcp三次握手及tls-握手时间" title="Direct link to heading">#</a></h3><p>不管是HTTP1.0/1.1 还是HTTPS, HTTP2.0， 都使用了TCP进行传输。HTTPS和HTTP2还需要使用TLS协议来进行安全传输。这就出现了两个握手延迟，而基于UDP协议的QUIC, 因为UDP本身没有连接的概念，连接建立时只需要一 次交互，半个握手的时间。区别如下图:</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-qid-new-14-32-http3.gif"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="多路复用丢包时的线头阻塞问题"></a>多路复用丢包时的线头阻塞问题<a class="hash-link" href="#多路复用丢包时的线头阻塞问题" title="Direct link to heading">#</a></h3><p>QUIC保留了HTTP2.0多路复用的特性，在之前的多路复用过程中，同一个TCP连接上有多个stream, 假如其中一个stream 丢包，在重传前后的stream 都会受到影响，而QUIC中一个连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream, 也就避免了线头阻塞问题。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="优化重传策略"></a>优化重传策略<a class="hash-link" href="#优化重传策略" title="Direct link to heading">#</a></h3><p>以往的TCP丢包重传策略是:在发送端为每一个封包标记一 个编号(sequence number),接收端在收到封包时，就会回传个带有对应编号的 ACK封包给发送端，告知发送端封包已经确实收到。当发送端在超过定时间之 后还没有收到回传的ACK,就会认为封包已经丢失， 启动重新传送的机制，复用与 原来相同的编号重新发送一次封包，确保在接收端这边没有任何封包漏接。这样的机制就会带来一些问题， 假设发送端总共对同一个封包发送了两次(初始+重传)， 使用的都是同一个sequence number: 编号N。之后发送端在拿到编号N封包的回传ACK时，将无法判断这个带有编号N的ACK,是接收端在收到初始封包后回传的ACK。这就会加大后续的重传计算的耗时。QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number, 每个编号 都唯一而且严格递增， 这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="流量控制"></a>流量控制<a class="hash-link" href="#流量控制" title="Direct link to heading">#</a></h3><p>通过流量控制可以限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收buffer, 优化记忆体被占用的空间。但是如果存在一个流量极慢的 stream ，光一个stream 就有可能佔用掉接收端所有的资源。QUIC为了避免这个潜在的HOL Blocking, 采用了连线层(connection flow control) 和Stream 层的(stream flow control) 流量控制，限制单- Stream 可以占用的最大buffer size。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="连接迁移"></a>连接迁移<a class="hash-link" href="#连接迁移" title="Direct link to heading">#</a></h3><p>TCP连接基于四元组(源IP、 源端口、目的IP、 目的端口)，切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，
当检测到网络变化时立刻建立新的TCP连接，即使这样，建立新的连接还是需要几百毫秒的时间。QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC连接不以四元组作为标识，而是使用一个64位的随机数，这个随机数被称为Connection ID, 对应每个stream,即使IP或者端口发生变化，只要Connection ID没有变化，那么连接依然可以维持。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http发展史"></a>HTTP发展史<a class="hash-link" href="#http发展史" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="web始祖http"></a>Web始祖HTTP<a class="hash-link" href="#web始祖http" title="Direct link to heading">#</a></h3><p>HTTP的全称是:超文本传输协议(HyperText Transfer Protocol)伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如TCP建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http与现代化浏览器"></a>HTTP与现代化浏览器<a class="hash-link" href="#http与现代化浏览器" title="Direct link to heading">#</a></h3><p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML )文档从WEB服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的WEB服务器上，用户端通过浏览器访问URL地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是些简单 的文字和图片， 同时我们的HTML页面有了CSS, JavaScript, 来丰富我们的页面展示，当ajax 的出现，我们又多了-种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-032345.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http基本优化"></a>HTTP基本优化<a class="hash-link" href="#http基本优化" title="Direct link to heading">#</a></h3><ul><li><p>带宽
如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p></li><li><p>延迟</p><ul><li><p>浏览器阻塞(HOL blocking) :浏览器会因为一 些原因阻塞请求。浏览器对于同一个域名，同时只能有4个连接(这个根据浏览器内核不同可能会有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞。</p></li><li><p>DNS查询(DNS Lookup)浏览器需要知道目标服务器的IP 才能建立连接。将域名解析为IP的这个系统就是DNS。 这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p></li><li><p>建立连接(initial connection) : HTTP 是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。下图为 三次握手流程图:</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-032536.png"></p></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http10和http11的一些区别"></a>HTTP1.0和HTTP1.1的一些区别<a class="hash-link" href="#http10和http11的一些区别" title="Direct link to heading">#</a></h3><p>HTTP1.0最早在网页中使用是在1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1 则在1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1 也是当前使用最为广泛的HTTP协议。主要区别主要体现在:</p><ul><li><code>缓存处理:</code>在HTTP1.0 中主要使用header 里的If-Modified- Since，Expires来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如Entity tag, If-Unmodified-Since, If-Match, If-.None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><code>带宽优化及网络连接的使用: </code>HTTP1.0 中，存在些浪费带宽的现象，例如客户端只是需要某 个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， HTTP1.1则在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是206 (Partial Content) ,这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><code>错误通知的管理:</code>在 HTTP1.1中新增了24个错误状态响应码，如409 (Conflict) 表示请求的资源与资源的当前状态发生冲突; 410 (Gone) 表示服务器上的某个资源被永久性的删除。</li><li><code>Host头处理:</code> 在HTTP1.0中认为每台服务器都绑定一个唯-的IP地址， 因此，请求消息中的 URL并没有传递主机名 (hostname) 。但随着 虚拟主机技术的发展， 在台物理服务 器上可以存在多个虚拟主机(Multi-homed Web Servers) ，并且它们共享一个IP 地址。HTTP1.1的请求消息和响应消息都应支持Host 头域，且请求消息中如果没有Host 头域会报告-个错误(400 Bad Request)</li><li><code>长连接: </code>HTTP 1.1 支持长连接(PersistentConnection) 和请求的流水线(Pipelining) 处理，在一个TCP连接.上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，其中长连接也就是对应在HTTP1.1中的Connection: keep-alive,- 定程度 上弥补了HTTP1.0 每次请求都要创建连接的缺点。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http10-和11现存的一些问题"></a>HTTP1.0 和1.1现存的一些问题<a class="hash-link" href="#http10-和11现存的一些问题" title="Direct link to heading">#</a></h3><ul><li>HTTP1.0和HTTP1.1 可以称做HTTP1.x, 正如上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li><li>HTTP1.X在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度 上无法保证数据的安全性。</li><li>HTTP1.x在使用时，header 里携带的内容过大，在定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端会增加用户流量。</li><li>虽然HTTP1.1 支持了keep-alive, 来弥补多次创建连接产生的延迟，但是keep-alive 使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep -alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。同样keep-alive 也无法解决线头阻塞(Head-of-line blocking, HOL)问题。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https登场"></a>HTTPS登场<a class="hash-link" href="#https登场" title="Direct link to heading">#</a></h3><p>  为了解决上面的一些问题，网景在1994 年创建了HTTPS, 并应用在网景导航者浏览器中。最初， HTTPS 是与SSL -起使用的，在SSL逐渐演变到TLS时(其实两个是一个东西，只是名字不同而已)，最新的HTTPS也由在2000 年五月公布的RFC 2818 正式确定下来。简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，Chrome和Firefox 都大力支持网站使用HTTPS,苹果也在iOS 10系统中强制APP使用HTTPS来传输数据，由此可见HTTPS势在必行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https与http的一些区别"></a>HTTPS与HTTP的一些区别<a class="hash-link" href="#https与http的一些区别" title="Direct link to heading">#</a></h3><ul><li>HTTPS协议需要到CA申请证书，-般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的TLS加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的默认端口也不一样，前者是80, 后者是443。</li><li>HTTPS的连接很简单，HTTPS协议是由TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https改造"></a>HTTPS改造<a class="hash-link" href="#https改造" title="Direct link to heading">#</a></h3><p>如果一个网站要全站由HTTP替换成HTTPS,可能需要关注以下几点:</p><ul><li><code>安装CA证书:</code>一般的证书都是需要收费的，也有免费的:<ul><li>Let&#x27;s Encrypt:免费， 快捷，支持多域名(不是通配符)，三条命令就可以签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。</li><li>Comodo PositiveSSL:收费， 但是比较稳定。</li></ul></li><li><code>配置WEB服务器:</code>在购买证书之后， 在证书提供的网站，上配置自己的域名，将证书下载下来之后，配置自己的WEB服务器，同时进行代码改造。</li><li><code>HTTPS会降低用户访问速度:</code> TLS 需要握手，HTTPS 对速度会有-定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS速度完全不逊于HTTP, 如果使用SPDY, HTTPS的速度甚至还要比HTTP快。相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="使用spdy提速你的网站"></a>使用SPDY提速你的网站<a class="hash-link" href="#使用spdy提速你的网站" title="Direct link to heading">#</a></h3><p>2012年Google 一声惊雷提出了SPDY (发音为&quot;speedy&quot;)的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS 和HTTP两者优点于一体的传输协议，主要解决:</p><ul><li><code>降低延迟:</code>针对 HTTP高延迟的问题，SPDY优雅的采取了多路复用(Multiplexing) 。多路复用通过多个请求stream 共享一个TCP连接的方式，降低了创建多个TCP的延迟同时提高了带宽的利用率。</li><li><code>请求优先级(Request Prioritization) :</code>多 路复用带来一个新的问题是， 在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第时间看 到网页内容。</li><li><code>header压缩: </code>前面提到HTTP1.x的header很多时候都是重复多余的，而有些header 的内容在不压缩的情况下则比较“庞大”(例如cookie 和user-agent等)。选择合适的压缩算法可以减小包的大小和数量，不仅可以节省资源，还可以缩短数据传递的延迟。</li><li><code>基于HTTPS的加密协议传输:</code>保留了 HTTPS 的TLS加密特性，大大提高了传输数据的可靠性。服务端推送(Server Push) :采用了 SPDY的网页，例如我的网页有一个sytle.css 的请求，在客户端收到sytle .css数据的同时，服务端会将index.js 的文件推送给客户端，当客户端再次尝试获取index.js 时就可以直接从缓存中获取到，不用再发请求了。</li></ul><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-033453.png"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.X的内容封装成一种新的frame 格式)，同时可以使用已有的SSL功能。</p><p>由于SPDY并不是一个标准协议， 后来SPDY 也未能单独成为正式标准， 不过SPDY 开发组的成员全程参与 了HTTP2.0 的制定过程。 SPDY也有自己的兼容性问题，在HTTP2.0 出来之后，大部分浏览器将不在支持。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http20的前世今生"></a>HTTP2.0的前世今生<a class="hash-link" href="#http20的前世今生" title="Direct link to heading">#</a></h3><p>有了HTTP1.X, 那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版(其实原本也是基于SPDY设计的)。但是，HTTP2.0跟SPDY仍有不同的地方，主要是以下两点:</p><ul><li>HTTP2.0 消息头的压缩算法采用HPACK算法，而非SPDY采用的DEFLATE算法。</li><li>HTTP2.0设计初期支持明文HTTP传输，而SPDY强制使用HTTPS,到后期两者都需要使用HTTPS。</li></ul><p>2015年9月，Google 宣布了计划，移除对SPDY 的支持，拥抱HTTP2.0, 并将在Chrome 51 中生效。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http20新特性"></a>HTTP2.0新特性<a class="hash-link" href="#http20新特性" title="Direct link to heading">#</a></h3><p>HTTP2.0的特性大部分和SPDY类似，主要有以下4个:</p><ul><li><p><code>新的二进制格式(Binary Format) :</code> HTTP1.X 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用一进制格式，实现方便且健壮。</p></li><li><p><code>多路复用(MultiPlexing) :</code>即连接共享， 即每一个request都是是用作连接共享机制的。一个request对应一个id,这样个连接 上可以有多个request, 每个连接的request 可以随机的混杂在一起，接收方可以根据request的id 将request再归属到各自不同的服务端请求里面。多路复用原理和keep alive区别如下图:</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-033806.png"></p></li><li><p><code>header 压缩:</code> 如上文中所言，对前面提到过HTTP1.x的header 带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache份header fields 表，既避免了重复header 的传输，又减小了需要传输的大小。</p></li><li><p><code>服务端推送(Server Push) :</code>同SPDY一样，HTTP2.0 也具有Server Push 功能。</p></li></ul><p>目前，有大多数网站已经启用HTTP2.0， 例如YouTuBe, 淘宝网等网站，利用Chrome 控制台可以查看是否启用Server Push, 如下图:</p><p><img src="https://chalee-typora.oss-cn-beijing.aliyuncs.com/2021-07-13-033936.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="http20的升级改造"></a>HTTP2.0的升级改造<a class="hash-link" href="#http20的升级改造" title="Direct link to heading">#</a></h3><p>对比HTTPS的升级改造，HTTP2.0 获取会稍微简单些，你可能需 要关注以下问题:</p><ul><li>前文说了HTTP2.0 需要基于HTTPS 的，并且现在主流的浏览器像Chrome, Firefox 表示还是只支持基于TLS部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，你需要做的就是将服务器进行升级，如果你使用Nginx, 需要在配置文件中启动相应的协议就可以了。</li><li>使用了HTTP2.0， 那么原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0 完全兼容HTTP1.X的语义，对于不支持HTTP2.0 的浏览器，Nginx 会自动向下兼容的。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/master/website/docs/question\http3.0及http发展.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_wj+Z"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/question/dev-server的运行"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« dev-server 是怎么跑起来的</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/question/https获取加密秘钥的过程"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">https 获取加密秘钥的过程 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#http30" class="table-of-contents__link">http3.0</a><ul><li><a href="#减少了tcp三次握手及tls-握手时间" class="table-of-contents__link">减少了TCP三次握手及TLS 握手时间</a></li><li><a href="#多路复用丢包时的线头阻塞问题" class="table-of-contents__link">多路复用丢包时的线头阻塞问题</a></li><li><a href="#优化重传策略" class="table-of-contents__link">优化重传策略</a></li><li><a href="#流量控制" class="table-of-contents__link">流量控制</a></li><li><a href="#连接迁移" class="table-of-contents__link">连接迁移</a></li></ul></li><li><a href="#http发展史" class="table-of-contents__link">HTTP发展史</a><ul><li><a href="#web始祖http" class="table-of-contents__link">Web始祖HTTP</a></li><li><a href="#http与现代化浏览器" class="table-of-contents__link">HTTP与现代化浏览器</a></li><li><a href="#http基本优化" class="table-of-contents__link">HTTP基本优化</a></li><li><a href="#http10和http11的一些区别" class="table-of-contents__link">HTTP1.0和HTTP1.1的一些区别</a></li><li><a href="#http10-和11现存的一些问题" class="table-of-contents__link">HTTP1.0 和1.1现存的一些问题</a></li><li><a href="#https登场" class="table-of-contents__link">HTTPS登场</a></li><li><a href="#https与http的一些区别" class="table-of-contents__link">HTTPS与HTTP的一些区别</a></li><li><a href="#https改造" class="table-of-contents__link">HTTPS改造</a></li><li><a href="#使用spdy提速你的网站" class="table-of-contents__link">使用SPDY提速你的网站</a></li><li><a href="#http20的前世今生" class="table-of-contents__link">HTTP2.0的前世今生</a></li><li><a href="#http20新特性" class="table-of-contents__link">HTTP2.0新特性</a></li><li><a href="#http20的升级改造" class="table-of-contents__link">HTTP2.0的升级改造</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 From chalee.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.047caa76.js"></script>
<script src="/assets/js/main.da97ff1e.js"></script>
</body>
</html>