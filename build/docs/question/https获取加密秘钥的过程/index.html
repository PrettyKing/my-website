<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="卫辰 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="卫辰 Blog Atom Feed"><title data-react-helmet="true">https 获取加密秘钥的过程 | 卫辰</title><meta data-react-helmet="true" property="og:url" content="http://githubci.faithcal.com/docs/question/https获取加密秘钥的过程"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="https 获取加密秘钥的过程 | 卫辰"><meta data-react-helmet="true" name="description" content="https 加密机制"><meta data-react-helmet="true" property="og:description" content="https 加密机制"><link data-react-helmet="true" rel="shortcut icon" href="/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://githubci.faithcal.com/docs/question/https获取加密秘钥的过程"><link data-react-helmet="true" rel="alternate" href="http://githubci.faithcal.com/docs/question/https获取加密秘钥的过程" hreflang="en"><link data-react-helmet="true" rel="alternate" href="http://githubci.faithcal.com/docs/question/https获取加密秘钥的过程" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.2a08f740.css">
<link rel="preload" href="/assets/js/runtime~main.047caa76.js" as="script">
<link rel="preload" href="/assets/js/main.da97ff1e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">卫辰</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">大前端</a><a class="navbar__item navbar__link" href="/md/devops">devops</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_cxYs react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/logo.png" alt="诗的远方" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">卫辰</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/intro">大前端</a></li><li class="menu__list-item"><a class="menu__link" href="/md/devops">devops</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">博客</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_lDyR"><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu menu--responsive thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_iZzd" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/browser/base-1">base-1</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">函数速查</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/function/searchPrams">searchPrams</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">javascript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/Proxy&amp;Reflect">Proxy 和 Reflect</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/design-pattern">设计模式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/eventloop">EventLoop</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/javascript-functional">函数式编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/meta-programming">元编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/JavaScript高级技巧">JavaScript高级技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/javaScript常见的错误类型">javaScript常见的错误类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/javascript/try-catch-finally执行顺序">有return的情况下try catch finally的执行顺序</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">node</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-framework">NodeJS 项目架构与优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-ioc">NodeJS 面向切面编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-performance">NodeJS 性能调优</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node/node-ssr">NodeJS 服务端渲染</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">性能调优</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/http">HTTP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/node-performance">NodeJS 性能调优</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-1">性能优化(一)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-2">性能优化(二)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/optimize/performance-optimization-3">性能优化(三)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">其他</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/C">C语言速成</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/CPP">C++ 速成</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/other/docker-publish">Docker 镜像打包和发布基本流程</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">问题描述</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/BFC">BFC相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/react-fiber">react的react-fiber</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vueHooks">vue 中的Hooks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/DNS的解析过程">DNS的解析过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/React中的有状态和无状态组件">React 中的有状态组件和无状态组件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/React动态加载路由实现按需加载">React 路由的动态加载模块，实现按需加载</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/Redux属性传递的原理">Redux怎么实现属性传递，介绍下原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/TreeShaking的原理">tree-shaking 的原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/css-旋转图片">css一直旋转的图片</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/css-水波纹">css水波纹</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/dev-server的运行">dev-server 是怎么跑起来的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/http3.0及http发展">http3.0 及 http发展历史</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/question/https获取加密秘钥的过程">https 获取加密秘钥的过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/localStorage加密原理">LocalStorage 加密原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/react中的diff">react diff算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue&amp;react的异同">vue&amp;react的理解和他们的异同</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue.$set原理">vue的 $set原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue中$方法说明">vue 中所有带$方法的说明</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue中的v-model">vue 中的v-model</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的data改编后会重新渲染吗">vue 中data中某个属性改变会触发视图重新渲染的吗</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的dom-diff算法">vue中的dom diff算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的keep-alive">vue keep-alive的实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的nextTick原理">vue的$nextTick原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的seo">vue 针对搜索引擎的seo优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue的指令">vue中的指令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue移动端滚动穿透问题">vue移动端滚动穿透问题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/vue组件的通信方式">vue组件的通信方式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack插件的实现">webpack中插件的实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack热更新原理">webpack 热更新原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的loader和plugin">webpack 的loader和plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的优化">webpack 及其优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/webpack的模块引用">webpack是怎么处理模块循环引用的情况的?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/从URL到页面加载分析">从输入 URL 到页面加载全过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/前端的单元测试">前端中的单元测试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/可提供代码执行环境的沙箱">场景：需求前端有一个编辑器，可提供执行代码的功能，这个执行的沙箱需要注意什么，怎么实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/在H5中实现长按保存图片">在H5中实现长按保存图片</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/增量式垃圾回收算法怎么实现的">增量式垃圾回收算法怎么实现的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/对react的看法">对react的看法，它的优缺点，使用过程中遇到的问题，如何解决的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/浏览器渲染流程">浏览器渲染流程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/浏览器里点击复制到剪贴板">浏览器里点击复制到剪贴板的方法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/组件曝光SDK">埋点场景题：如何设计一个通过组件曝光的sdk（计算路由跳转层级、停留时间等）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/网站的seo处理">网站的seo处理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/虚拟DOM">对虚拟DOM的理解?虚拟DOM主要做了什么?虚拟DOM本身是什么?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/解析HTML的过程">浏览器解析 HTML 文件的过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/question/首页优化">提升页面性能和首页优化</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">docker</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker image Build 高级">Docker image Build 高级</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker-compose基本语法">Docker-compose基本语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Dockerfile语法">Dockerfile语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker基础速查">Docker基础速查</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Docker网络化配置">Docker网络化配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Namespace-网络">Namespace-网络</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/Yaml语法">Yaml语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/docker中进程的信号">docker中进程的信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docker/安装Docker软件">安装Docker软件</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Kubernetes</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s/k8s-前置环境">k8s-前置环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s/redhat8安装docker">redhat8安装docker</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TypeScript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/开篇：用正确的方式学习 TypeScript">开篇：用正确的方式学习 TypeScript</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/工欲善其事：打造最舒适的 TypeScript 开发环境">工欲善其事：打造最舒适的 TypeScript 开发环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/进入类型的世界：理解原始类型与对象类型">进入类型的世界：理解原始类型与对象类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/掌握字面量类型与枚举，让你的类型再精确一些">掌握字面量类型与枚举，让你的类型再精确一些</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/函数与 Class 中的类型：详解函数重载与面向对象">函数与 Class 中的类型：详解函数重载与面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/探秘内置类型：any、unknown、never 与类型断言">探秘内置类型：any、unknown、never 与类型断言</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程好帮手：TypeScript 类型工具（上）">类型编程好帮手：TypeScript 类型工具（上）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程好帮手：TypeScript 类型工具（下）">类型编程好帮手：TypeScript 类型工具（下）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程基石：TypeScript 中无处不在的泛型">类型编程基石：TypeScript 中无处不在的泛型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/结构化类型系统：类型兼容性判断的幕后">结构化类型系统：类型兼容性判断的幕后</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型系统层级：从 Top Type 到 Bottom Type">类型系统层级：从 Top Type 到 Bottom Type</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型里的逻辑运算：条件类型与 infer">类型里的逻辑运算：条件类型与 infer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/内置工具类型基础：别再妖魔化工具类型了！">内置工具类型基础：别再妖魔化工具类型了！</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/反方向类型推导：用好上下文相关类型">反方向类型推导：用好上下文相关类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/函数类型：协变与逆变的比较">函数类型：协变与逆变的比较</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/了解类型编程与类型体操的意义，找到平衡点">了解类型编程与类型体操的意义，找到平衡点</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/内置工具类型进阶：类型编程进阶">内置工具类型进阶：类型编程进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基础类型新成员：模板字符串类型入门">基础类型新成员：模板字符串类型入门</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/类型编程新范式：模板字符串工具类型进阶">类型编程新范式：模板字符串工具类型进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/工程层面的类型能力：类型声明、类型指令与命名空间">工程层面的类型能力：类型声明、类型指令与命名空间</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/在 React 中愉快地使用 TypeScript：内置类型与泛型坑位">在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍">让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/全链路 TypeScript 工具库，找到适合你的工具">全链路 TypeScript 工具库，找到适合你的工具</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/说说 TypeScript 和 ECMAScript 之间那些事儿">说说 TypeScript 和 ECMAScript 之间那些事儿</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/装饰器与反射元数据：了解装饰器基本原理与应用">装饰器与反射元数据：了解装饰器基本原理与应用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/控制反转与依赖注入：基于装饰器的依赖注入实现">控制反转与依赖注入：基于装饰器的依赖注入实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/TSConfig 全解（上）：构建相关配置">TSConfig 全解（上）：构建相关配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/TSConfig 全解（下）：检查相关、工程相关配置">TSConfig 全解（下）：检查相关、工程相关配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基于 Prisma + NestJs 的 Node API ：前置知识储备">基于 Prisma + NestJs 的 Node API ：前置知识储备</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署">基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/玩转 TypeScript AST：AST Checker 与 CodeMod">玩转 TypeScript AST：AST Checker 与 CodeMod</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">工程化</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/devops/CICD">前端工程化之CI/CD</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/devops/K8S">K8S 基础</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="markdown"><header><h1 class="h1Heading_dC7a">https 获取加密秘钥的过程</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https-加密机制"></a>https 加密机制<a class="hash-link" href="#https-加密机制" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="11为什么需要加密"></a>1.1为什么需要加密<a class="hash-link" href="#11为什么需要加密" title="Direct link to heading">#</a></h3><p>因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、 通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="12什么是对称加密"></a>1.2什么是对称加密<a class="hash-link" href="#12什么是对称加密" title="Direct link to heading">#</a></h3><p>就是有一个密钥，它可以对一段内容加密，加密后只能用它才能解密看到原本的内容，和我们日常生活中用的钥匙作用差不多。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="13对称加密是否可以保证数据安全"></a>1.3对称加密是否可以保证数据安全<a class="hash-link" href="#13对称加密是否可以保证数据安全" title="Direct link to heading">#</a></h3><p><code>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的(除非密钥被破解)。</code></p><p>但是有个最大的问题，<code>这个密钥怎么让传输的双方知晓，同时不被别人知道</code>。</p><p>如果由服务器生成个密钥并传输给浏览器， 那这个传输过程 中密钥被别人劫持弄到手了怎么办? 之后他就能用密 钥解开双方传输的任何内容了，所以这么做当然不行。</p><p>换种思路?试想一下， 如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行啦!这么做显然不现实。</p><blockquote><p>那如何解决?这就需要神奇的非对称加密?</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="14什么是非对称加密"></a>1.4什么是非对称加密<a class="hash-link" href="#14什么是非对称加密" title="Direct link to heading">#</a></h3><p>有两把密钥，通常把叫做公钥、 一把叫做私钥， 用公钥加密的内容必 须用私钥才能解开，同样，私钥加密的内容 只有公钥能解开。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="15非对称加密可以保证数据安全吗"></a>1.5非对称加密可以保证数据安全吗?<a class="hash-link" href="#15非对称加密可以保证数据安全吗" title="Direct link to heading">#</a></h3><p>鉴于非对称加密的机制，我们可能会有这种思路:服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了!<code>因为只有服务器有相应的私钥能解开这条数据。</code></p><p>然而由服务器到浏览器的这条路怎么保障安全?如果服务 器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。所以目前似乎<code>只能保证由浏览器向服务器传输数据时的安全性</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="16改良的非对称加密方案"></a>1.6改良的非对称加密方案<a class="hash-link" href="#16改良的非对称加密方案" title="Direct link to heading">#</a></h3><p>我们已经理解通过-组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了?</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥AA;浏览器拥有用于非对称加密的公钥B、私钥BB。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>浏览器把公钥B明文传输给服务器。</li><li>之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥AA解密。由于只有服务器拥有这个私钥AA可以解密，所以能保证这条数据的安全。</li><li>服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥BB解密。由于只有浏览器拥有这个私钥BB可以解密，所以能保证这条数据的安全。</li></ol><p>的确可以，但是Https并没有采取这种方案，其中最重要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有 些力不从心，而对称加密快很多。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="17非对称加密对称加密"></a>1.7非对称加密+对称加密<a class="hash-link" href="#17非对称加密对称加密" title="Direct link to heading">#</a></h3><p>既然非对称加密耗时，非对称加密+对称加密结合可以吗?而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥AA。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li><li>服务器拿到后用私钥AA解密得到密钥X。</li><li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。</li></ol><p>这样是不是就很完美了，Https就是 采用的这种方案。但是这样还是会存在漏洞。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="18中间人攻击"></a>1.8中间人攻击<a class="hash-link" href="#18中间人攻击" title="Direct link to heading">#</a></h3><p>中间人的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥AA解开拿到它!然而中间人却完全不需要拿到密钥AA就能干坏事。</p><ol><li>某网站拥有 用于非对称加密的公钥A、私钥AA。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>中间人劫持到公钥A, 保存下来，把数据包中的公钥A替换成自己伪造的公钥B (它当然也拥有公钥B对应的私钥BB)。</li><li>浏览器随机生成个用于 对称加密的密钥X，用公钥B (浏览器不知道公钥被替换 了)加密后传给服务 器。</li><li>中间人劫持后用私钥BB解密得到密钥X，再用公钥A加密后传给服务器。服务器拿到后用私钥AA解密得到密钥X。</li></ol><p>这样在双方都不会发现异常的情况下，中间人得到了密钥X。<code>根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。</code></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="19如何证明浏览器收到的公钥定是该网站的公钥"></a>1.9如何证明浏览器收到的公钥定是该网站的公钥<a class="hash-link" href="#19如何证明浏览器收到的公钥定是该网站的公钥" title="Direct link to heading">#</a></h3><p>现实生活中，如果想证明某身份证号一定是小明的， 怎么办?看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢?给网站颁发个“ 身份证”?</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="110数字证书"></a>1.10数字证书<a class="hash-link" href="#110数字证书" title="Direct link to heading">#</a></h3><p>网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书， 数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。然而这里又有-个显而易见的问题了，证书本身的传输过程中，如何防止被篡改?即如何证明证书本身的真实性?身份证有些防伪技术， 数字证书也有对应的防伪措施。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-11如何放防止数字证书被篡改"></a>1. 11如何放防止数字证书被篡改?<a class="hash-link" href="#1-11如何放防止数字证书被篡改" title="Direct link to heading">#</a></h3><p>我们把证书内容生成一份“ 签名”，比对证书内容和签名是否一致就能察 觉是否被篡改。这种技术就叫数字签名。
数字签名有两种功效:</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性，证明数据是否未被篡改过。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https-获取加密秘钥的过程"></a>https 获取加密秘钥的过程<a class="hash-link" href="#https-获取加密秘钥的过程" title="Direct link to heading">#</a></h2><p>经过上边的分析，现在再来理解就比较容易理解了。</p><ul><li>首先，客户端发起握手请求，以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息(这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址， 然后连接到服务端的443端口。</li><li>服务端的配置，采用HTTPS协议的服务器必须要有套数字证书， 可以自己制作， 也可以向组织申请。区别就是自己颁发 的证书需要客户端验证通过， 才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。 如果对公钥不太理解，可以想象成一 把钥匙和一个锁头， 只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li>服务端返回协商的信息结果，包括选择使用的协议版本version,选择的加密套件cipher suite, 选择的压缩算法compression method、 随机数random_ S以及证书。(这个证书其实就是公明，只是包含了很多信息，如证书的颁发机构，过期时间等等。)</li><li>客户端验证证书的合法性，包括可信性，是否吊销，过期时间和域名。(这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个随机值。然后用证书(也就是公钥)对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。)</li><li>客户端使用公匙对对称密匙加密，发送给服务端。(这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密
了。)</li><li>服务器用私钥解密，拿到对称加密的密匙。(服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起， 这样除非知道私
钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。)</li><li>传输加密后的信息，这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。</li><li>客户端解密信息，客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="https必须在每次请求中都要先在ssl-tl-s层进行握手传输密钥吗"></a>HTTPS必须在每次请求中都要先在SSL /TL S层进行握手传输密钥吗?<a class="hash-link" href="#https必须在每次请求中都要先在ssl-tl-s层进行握手传输密钥吗" title="Direct link to heading">#</a></h2><p>如果每次https的请求都需 要进行TL S的握手，TLS的握手那么复杂，势必会对通信带来较大的延时，这对注重用户体验的网站来说， 是不可接受的。那么有什么办法可以避免这种情况吗?</p><p>其实是通过一个Session Identifier (会话标识符)，该Session ID是TLS握手中生成的Session ID。 服务端可以将Session ID协商后的信息存起来，浏览器也可以保存Session ID, 并在后续的Client Hello 握手中带上它，如果服务端能找到与之匹配的信息，就可以完成一 次快速握手。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/master/website/docs/question\https获取加密秘钥的过程.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_wj+Z"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/question/http3.0及http发展"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« http3.0 及 http发展历史</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/question/localStorage加密原理"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">LocalStorage 加密原理 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#https-加密机制" class="table-of-contents__link">https 加密机制</a><ul><li><a href="#11为什么需要加密" class="table-of-contents__link">1.1为什么需要加密</a></li><li><a href="#12什么是对称加密" class="table-of-contents__link">1.2什么是对称加密</a></li><li><a href="#13对称加密是否可以保证数据安全" class="table-of-contents__link">1.3对称加密是否可以保证数据安全</a></li><li><a href="#14什么是非对称加密" class="table-of-contents__link">1.4什么是非对称加密</a></li><li><a href="#15非对称加密可以保证数据安全吗" class="table-of-contents__link">1.5非对称加密可以保证数据安全吗?</a></li><li><a href="#16改良的非对称加密方案" class="table-of-contents__link">1.6改良的非对称加密方案</a></li><li><a href="#17非对称加密对称加密" class="table-of-contents__link">1.7非对称加密+对称加密</a></li><li><a href="#18中间人攻击" class="table-of-contents__link">1.8中间人攻击</a></li><li><a href="#19如何证明浏览器收到的公钥定是该网站的公钥" class="table-of-contents__link">1.9如何证明浏览器收到的公钥定是该网站的公钥</a></li><li><a href="#110数字证书" class="table-of-contents__link">1.10数字证书</a></li><li><a href="#1-11如何放防止数字证书被篡改" class="table-of-contents__link">1. 11如何放防止数字证书被篡改?</a></li></ul></li><li><a href="#https-获取加密秘钥的过程" class="table-of-contents__link">https 获取加密秘钥的过程</a></li><li><a href="#https必须在每次请求中都要先在ssl-tl-s层进行握手传输密钥吗" class="table-of-contents__link">HTTPS必须在每次请求中都要先在SSL /TL S层进行握手传输密钥吗?</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 From chalee.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.047caa76.js"></script>
<script src="/assets/js/main.da97ff1e.js"></script>
</body>
</html>